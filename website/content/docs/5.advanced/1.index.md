---
title: 'Component anatomy'
description: 'Learn about the anatomy of Shuriken UI components.'
layout: 'default'
---

# Component anatomy

Learn about the anatomy of Shuriken UI components.

## @shuriken-ui/tailwind

We came up with the idea of creating a collection of Tailwind CSS plugins that would allow us to use the same components across different environments, while keeping the same Tailwind CSS classes. This is how `@shuriken-ui/tailwind` was born. Components would be identified by real life class names, like `.button` or `.input`.

## Classes vs utilities

In Shuriken UI v4, we completely dropped this approach, as Tailwind v4 is more than ever an utility first framework. On top of that, our CSS codebase grew more and more complex and harder to maintain. We decided to go back to the basics, and use Tailwind CSS utilities to style our components. While doing that, we also reduced the final CSS bundle size by more than a half, as there is no more redundant CSS code.

::info-block{icon='logos:tailwindcss-icon'}
You should be familiar with Tailwind CSS and its concepts before using Shuriken UI. If not, you should go through the Tailwind CSS [documentation](https://tailwindcss.com){:target="_blank"} and make some experiments in the Tailwind CSS official [playground](https://play.tailwindcss.com/){:target="_blank"}.
#title
Important note
::

## Reka UI

with the release of the Tailwind V4 beta, as we decided to align with it, we were facing a major refactor that would impact the entire library. We decided to take this opportunity to rethink the way we were building our components, and to make them more flexible and easier to maintain. This is how [Reka UI](https://reka-ui.com/){:target="_blank"} was brought in the project.

![Reka UI](/img/content/docs/reka-ui.png)

We've been eyeing [Radix UI](https://www.radix-ui.com/){:target="_blank"} for a while, and we were impressed by the way they were building their components as primitives focusing on accessibility first. Unfortunately, Radix is for React, and there were no Vue alternatives, besides some discontinued projects. 

It was until we stumbled upon Reka UI (formerly Radix Vue), a Vue port of Radix UI, that we decided to give it a try. The results exceeded our expectations, and we decided to use Reka UI as the foundation of our component system.

::info-block{icon='nui-icon:rekaui-icon'}
You should be familiar with Reka UI and its concepts before using Shuriken UI. If not, you should go through the Reka UI [documentation](https://reka-ui.com/docs/overview/getting-started){:target="_blank"}.
#title
Important note
::

## Anatomy changes

Building on top of Reka made us switch the way we build components. Rather than building monolithic components, we decided to split them into smaller parts, making them more flexible and easier to maintain.

### The Field example

In the previous version, we have single block components like inputs and select. By single block, we mean that the component is a single block of code, with all the logic, styles and templates in the same file, making components hard to maintain, and hard to extend. 

Let's take the `Input` component and look at how it was used in the previous version:

::code-group

```vue [example.vue]
<script setup lang="ts">
const value = ref('')
</script>

<template>
  <BaseInput 
    v-model="value" 
    type="text" 
    label="Search records..."
    placeholder="Type something..." 
    rounded="md"
    contrast="default-contrast"
    error="This field is required"
    icon="lucide:search"
  />
</template>
```

::

In the Shuriken UI v4, we removed all unecessary props, and split the component into smaller parts. The `Input` component is now a composition of smaller components, like `Field`, `Label`, `Input`, `Error`, etc... This way, we make the component more flexible, and easier to maintain. Here is how the `Input` component is used in the new version:

::code-group

```vue [example.vue]
<script setup lang="ts">
const value = ref('')
</script>

<template>
  <BaseField> 
    <div class="w-full inline-flex">
      <BaseFieldLabel class="flex items-center justify-between w-full">
        <div>
          <span>BaseInput</span>
          <BaseFieldRequiredIndicator  />
        </div>
      </BaseFieldLabel>
    </div>
    <div class="relative">
      <BaseFieldController>
        <BaseInput placeholder="placeholder" />
      </BaseFieldController>
      <div class="absolute z-0 end-4 top-3 pointer-events-none" >
        <BaseFieldLoadingIndicator/>
        <BaseFieldSuccessIndicator />
        <BaseFieldErrorIndicator />
      </div>
    </div>
    <div class="mt-2 flex flex-col">
      <BaseFieldError class="mb-1 block">
        The input is invalid because ...
      </BaseFieldError>
      <BaseFieldDescription>
        Lorem ipsum dolor sit amet consectetur adipiscing elit.
        <BaseLink to="#" class="text-primary-600 dark:text-primary-400">
          Learn more
        </BaseLink>
      </BaseFieldDescription>
    </div>
  </BaseField>
</template>
```

::

You can immediately notice that there are much more smaller components now composing the input field. This way, we make the component more flexible and much more easier to maintain.

::info-block{icon='nui-icon:shurikenui-icon'}
In most cases, you won't have to use as much components. However, since they can look a little bit more verbose, we still plan to make shortcut versions of the components that will agregate all the required components for you.
#title
Important note
::
